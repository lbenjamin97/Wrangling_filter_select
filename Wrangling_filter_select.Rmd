---
title: "Data Wrangling - Part I"
subtitle: "StatPREP R Workshops"
author: "Leetambra Benjamin"
output: html_document
---

## Setting things up

We need to load libraries and read the data into R first.

```{r setup, include=FALSE}
# Don't forget to load your libraries
library(tidyverse)
library(ggplot2movies)
library(ggformula)
library(dplyr)
library(mosaicData)
```



# This loads the data from the ggplot2movies package

```{r}
data(movies)
```


```{r}
names(movies)
```

```{r}
head(movies)
```
```{r}
summary(movies)
```



```{r}
high_rated <- select(movies , rating = 8)
```

```{r}
selected_data <- select(movies, title, rating)
```
It's always a good idea to do some recon work first. What do the data look like? How many observations and variables do we have? What are the variable names?

```{r}
str(movies)
```
  
# View() opens the data in another window. 'head(movies)' will show the first few rows.
#View(movies)

# If the data come from a package, you can get the help documentation this way
?movies

dim(movies)     # always rows x columns
names(movies)   # a good way to keep track of variable names for later use



```{r}
dim(movies)
```



```{r}
names(movies)
```


## Motivation for Wrangling

Now that we have a sense of our data, we can start to dig a little deeper into the details of things. One of the main reasons data wrangling is so important to statisticians and data scientists is that we often collect waaaay more data than we actually need to answer a particular question. You may want to ask the following questions:

- What is the average movie rating?

```{r}
mean(movies$rating, na.rm = TRUE)
```


- What is the median budget for a movie?

```{r}
median(movies$budget, na.rm = TRUE)
```

But after looking at all of the movies recorded here, the more precise questions might turn out to be:

- What is the average rating *of movies longer than 60 minutes?*

```{r}
library(dplyr)
library(mosaicData)
```


```{r}
movies %>%
  filter(length == 68) %>%
  summarise(avg_rating = mean(rating, na.rm = TRUE))
```
```{r}
movies %>%
  filter(length == 68) %>%
  summarise(avg_rating = mean(rating, na.rm = TRUE))
```


                                

- What is the median budget *of animated films compared to documentaries?*

```{r}
movies %>%
  filter(Animation == 1 | Documentary == 1) %>%
  mutate(type = case_when(
    Animation == 1 ~ "Animation",
    Documentary == 1 ~ "Documentary"
  )) %>%
  group_by(type) %>%
  summarise(median_budget = median(budget, na.rm = TRUE))
```

We often find that the whole data frame is not necessary or even helpful to answer our questions. We need to simplify the data in certain ways. Since there are only two dimensions to a data frame like this, we will discuss two ways of reduction:

- `filter()` to reduce the number of observations/rows

```{r}
library(dplyr)
filtered_data <- movies %>%
  filter(year > 2000)
```


- `select()` to reduce the number of variables/columns


```{r}
movies %>%
  filter(length == 68) %>%
  summarise(avg_rating = mean(rating, na.rm = TRUE))
```

```{r}
selected_data <- movies %>%
  select(title, year, rating)
```

```{r}
simple_data <- movies %>%
  filter(year > 2000, rating >= 8) %>%
  select(title, year, rating)
```





### Filtering - Review

This one is probably the most useful verb for data wrangling. You can see from the initial data check, there are 58788 movies. Some of these are even from before 1900! Let's consider only looking into movies that were made since the "New Hollywood" era, 1965 (according to a wikipedia search). How many movies does that include?

```{r}
# Pay attention to the usage of the pipe
movies %>%               # start with the full dataset, and then
  filter(year >= 1965)   # give me only movies where the year is greater than or equal to 1965
```

```{r}
movies %>%
  filter(!is.na(mpaa)) %>%
  group_by(mpaa) %>%
  summarise(
    avg_rating = mean(rating, na.rm = TRUE),
    count = n()
  )
```



# Some simple practice and review for using filters

# How many movies since 1965 have a run-time greater than 60 minutes?

```{r}
movies %>%
  filter(year >= 1965, length > 60) %>%
  summarise(count = n())
```
# Show all movies with more than 500 votes and an average rating of at least 9

```{r}
movies %>%
  filter(mpaa == "PG-13") %>%
  summarise(count = n())
```

# How many PG-13 movies are in this dataset? Remember to use quotations ("") when filtering characters/strings

```{r}
movies %>%
  filter(mpaa == "PG-13") %>%
  summarise(count = n())


```

# I want only movies with an MPAA rating over PG (there are no G movies). Hint: think about what you don't want and double check to see the filter completely worked.

```{r}
movies %>%
  filter(mpaa %in% c("PG-13", "R", "NC-17")) %>%
  summarise(count = n())
```


Often there are a lot of missing values, or `NA`s, in the budget variable. This is another characteristic of real data, and one that we often need to deal with. The function, `is.na()` is useful here. `is.na()` will identify all of the missing values and evaluates automatically as a TRUE/FALSE for each row, which eliminates the need to use any logical symbols.

# Alter the code above to subset all of the movies where we do have budget information.


```{r}
movies %>%
  filter(is.na(budget))
```

# Another, simpler way to do this specific filter is with the drop_na() function
movies %>%
  drop_na(budget)

```{r}
movies %>%
  filter(!is.na(budget))
```

It is also nice to save your subset data for use later in your analysis. Notice that each time we ran the code above, R just showed us the data, it did not save it anywhere. Creating a new object allows us to refer back to that filtered/selected data later.

```{r}
movies_modern <- movies %>%    # Remember that '<-' assigns a new object. Preserve your original dataset by creating a new name
  filter(year >= 1965) %>%
  drop_na(budget)

# When running the code above, nothing seems to happen...
# But really, you didn't ask R to show anything, just to save something
# ask for movies_2000 to make sure it worked
movies_modern
```

# Show the first 6 rows to verify
```{r}
head(movies_modern)
```


One more useful way to filter a character variable is to base it on part of the value, or a string subset. You can use `str_detect()` for this. To use this function, just add the variable name and words or partial word you would like to detect.


library(dplyr)
library(stringr)  # str_detect() is from this package
```{r}
movies %>%
  filter(str_detect(title, "Harry Potter"))  # filters rows where 'title' contains "Harry Potter"
```

```{r}
library(stringr)

```
```{r}
library(dplyr)
```

```{r}
movies %>%
  filter(str_detect(title, "Godzilla"))
```
# Which Batman movies are in the dataset?
```{r}
library(stringr)

batman_movies <- movies %>%
  filter(str_detect(title, "Batman"))

batman_movies

```

> A note of caution: This method does not account for misentries and bad data. A mispelled word could cause an observation to escape your filter. This is only scratching the surface of what we can do with strings in R, [here is a nice chapter to get more info on handling strings](https://r4ds.had.co.nz/strings.html)


### Select

Alright, there are countless ways we can create subsets of our data to better suit our needs. Another way we can improve our data experience is by selecting only the variables (or columns) we are interested in using. For organizational and practical (which we'll demonstrate later) purposes, it's nice to simplify what we are looking at. Let's create a subset of just the movie titles, year, and ratings.

```{r}
movies %>%
  select(title, year, rating)
```


Notice that there are a bunch of ratings percentiles (`r1`-`r10`) that I don't really plan on using. We can still use the '!' as a logical negative here.

```{r}
movies %>%
  select(!c(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10))
```

> Advanced variable selection using partial variable names

`starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` can all grab multiple variables at once.

```{r}
library(dplyr)
movies_clean <- movies %>%
select(!num_range("r", 1:10))
head(movies_clean)
```
Filtering and variable selection can happen in the same pipe. Give me the title, rating, and budget for all action movies 2000 or later, with known budget.

```{r eval=FALSE}
movies %>%
filter(year >= 2000 & Action == 1) %>%              
select(title, rating, budget)
```


## Arrange


```{r}
movies_2000 <- movies %>%    
filter(year >= 2000 & Action == 1) %>%
drop_na(budget) %>%
select(title, rating, budget)
movies_2000
```




Let's create a new data subset of action movies with a budget since 2000.

```{r}
movies_2000 <- movies %>%
filter(year >= 2000 & Action == 1) %>%
drop_na(budget) %>%
select(title, rating, budget)
```


You'll learn some more summarizing techniques later, but I want to show one more useful verb: `arrange()`. This function allows you to sort columns by ascending and descending order. What movies in `movies_2000` have the highest budget?


```{r}
movies_2000 %>%
  arrange(desc(rating)) %>%
  head(10)    # Show top 10 highest rated action movies
```

# You can include multiple arrangements in the same function

movies_2000 %>%
  arrange(rating, desc(budget))  # these are the lowest rated movies arranged by largest budget


```{r}
movies_2000 %>%
  arrange(rating, desc(budget))
```

# Using the original 'movies' data, what is the longest movie? What is the oldest movie?


```{r}
movies %>%
drop_na(length) %>%
arrange(desc(length)) %>%
select(title, year, length) %>%
head(1)
```
```

```{r}
```



## Scavenger Hunt

See if you can answer these questions:

1. How many movies were released in 1995?

```{r}

```


2. Which Comedies with an MPAA rating, over 120 minutes have a rating above 8?

```{r}

```

3. Create a subset of only Harry Potter movies with the title, rating, budget, and votes. Which movies are included in this data? Which is highest rated? Which has the most votes on imdb.com?

```{r}

```

4. What is the highest budget for a movie that is an Animation or Comedy with at least 100 votes?

```{r}

```

5. Is your favorite movie in the dataset? What other questions could you ask or answer using `filter()`, `select()`, and `arrange()`?

```{r}

```








